{
    "name": "AnimeKai Streamer",
    "version": "1.1.0",
    "author": "Animex",
    "description": "Fetches streaming iframe URLs from AnimeKai.to using a MAL ID. Currently only supports subbed anime.",
    "type": [
        "ANIME_STREAMING"
    ],
    "requirements": ["selenium", "httpx", "beautifulsoup4"]
}
---
import time
import httpx
import asyncio
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from typing import Optional

# --- Constants ---
BASE_URL = "https://animekai.to"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
    "Referer": BASE_URL
}

# --- Internal Helper Functions ---

def scrape_episode_iframe(anime_slug, episode_number):
    """
    Scrapes the iframe source URL for a specific anime episode from AnimeKai.

    Args:
        anime_slug (str): The URL slug for the anime (e.g., 'attack-on-titan-nk0p').
        episode_number (int): The episode number to scrape.

    Returns:
        str: The scraped iframe src URL, or None if not found.
    """
    # 1. Construct the target URL
    url = f"https://animekai.to/watch/{anime_slug}#ep={episode_number}"
    print(f"Navigating to: {url}")

    # --- Setup Selenium WebDriver ---
    options = webdriver.ChromeOptions()
    options.add_argument('--headless')  # Run without opening a browser window
    options.add_argument('--log-level=3') # Suppress console logs
    options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")


    driver = webdriver.Chrome(options=options)
    
    iframe_src = None

    try:
        # 2. Navigate to the page
        driver.get(url)

        # Use WebDriverWait for robust waiting
        wait = WebDriverWait(driver, 20) # Wait for up to 20 seconds

        # 3. Wait for the main play button and click it
        print("Waiting for the play button to appear...")
        play_button = wait.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, '#player .play-btn'))
        )
        print("Play button found. Clicking now...")
        
        # Sometimes a direct click is intercepted, a JavaScript click is more reliable
        driver.execute_script("arguments[0].click();", play_button)

        # 4. Wait for the iframe to be loaded inside the player div
        print("Waiting for the iframe to load...")
        iframe_element = wait.until(
            EC.presence_of_element_located((By.CSS_SELECTOR, '#player iframe'))
        )
        
        # 5. Extract the 'src' attribute from the iframe
        iframe_src = iframe_element.get_attribute('src')
        print("Successfully found the iframe.")

    except TimeoutException:
        print("Error: A timeout occurred. The play button or iframe did not load in time.")
        print("This could be due to a slow network, bot detection, or a change in the website structure.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        # 6. Close the browser
        driver.quit()
        
    return iframe_src


# --- Main Module Function ---

async def get_iframe_source(mal_id: int, episode: int, dub: bool) -> Optional[str]:
    """
    Gets the streaming iframe source for an anime episode using its MAL ID.
    Now uses the /map/file/animekai endpoint to get the slug directly.

    Args:
        mal_id (int): MyAnimeList ID of the anime.
        episode (int): The episode number.
        dub (bool): Whether the dubbed version is requested.

    Returns:
        The iframe source URL or None if an error occurs.
    """
    if dub:
        print("AnimeKai-Module: Dubbed anime is not supported.")
        return None

    async with httpx.AsyncClient(headers=HEADERS, follow_redirects=True) as client:
        # 1. Fetch slug from the local endpoint
        try:
            print(f"AnimeKai-Module: Fetching slug for MAL ID {mal_id} from /map/file/animekai endpoint.")
            resp = await client.get("http://0.0.0.0:7275/map/file/animekai", timeout=10)
            resp.raise_for_status()
            animekai_map = resp.json()
            anime_slug = animekai_map.get(str(mal_id))
            print(f"AnimeKai-Module: Fetched slug: {anime_slug.strip().split('/')[-1]}")
            if not anime_slug:
                print(f"AnimeKai-Module: No slug found for MAL ID {mal_id}.")
                return None
        except Exception as e:
            print(f"AnimeKai-Module: Failed to fetch slug from endpoint: {e}")
            return None

        # 2. Scrape the iframe source using Selenium in a thread-safe way
        try:
            iframe_src = scrape_episode_iframe(anime_slug.strip().split('/')[-1], episode)
            return iframe_src
        except Exception as e:
            print(f"AnimeKai-Module: An error occurred while running the Selenium scraper: {e}")
            return


async def get_download_link(mal_id: int, episode: int, dub: bool, quality: str) -> Optional[str]:
    """
    Fetches the direct download link for an anime episode. (Sync)
    This function is now aligned with the working logic from test.py.
    """
    print(f"9anime-Module: Starting download process for MAL ID {mal_id}, Ep {episode}")
    if dub:
        print("AnimeKai-Module: Dubbed anime is not supported.")
        return None

    async with httpx.AsyncClient(headers=HEADERS, follow_redirects=True) as client:
        # 1. Fetch slug from the local endpoint
        try:
            print(f"AnimeKai-Module: Fetching slug for MAL ID {mal_id} from /map/file/animekai endpoint.")
            resp = await client.get("http://0.0.0.0:7275/map/file/animekai", timeout=10)
            resp.raise_for_status()
            animekai_map = resp.json()
            anime_slug = animekai_map.get(str(mal_id))
            print(f"AnimeKai-Module: Fetched slug: {anime_slug.strip().split('/')[-1]}")
            if not anime_slug:
                print(f"AnimeKai-Module: No slug found for MAL ID {mal_id}.")
                return None
        except Exception as e:
            print(f"AnimeKai-Module: Failed to fetch slug from endpoint: {e}")
            return None

        # 2. Scrape the iframe source using Selenium in a thread-safe way
        try:
            iframe_src = scrape_episode_iframe(anime_slug.strip().split('/')[-1], episode)
            return iframe_src
        except Exception as e:
            print(f"AnimeKai-Module: An error occurred while running the Selenium scraper: {e}")
            return